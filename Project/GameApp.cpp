/*************************************************************************//*!
					
					@file	GameApp.cpp
					@brief	基本ゲームアプリ。

															@author	濱田　享
															@date	2014.05.14
*//**************************************************************************/

//INCLUDE
#include	"GameApp.h"
#include	"Player.h"
#include	"Stage.h"
#include	"Stage1.h"

CCamera				gCamera;
CVector3			gCameraPosition;
CVector3			gTargetPosition;
CVector3			gUpVector;
float				gRotUp;

CDirectionalLight	gLight;
CPlayer				gPlayer;
CEnemy				gEnemyArray[ENEMY_MAX_COUNT];
CEnemyShot			gShotArray[ENEMYSHOT_COUNT];
CMeshContainer		gEnemyShotMesh;

CStage				gStage;

bool				gbDebug = false;

/*************************************************************************//*!
		@brief			アプリケーションの初期化
		@param			None
				
		@return			TRUE		成功<br>
						それ以外	失敗、エラーコードが戻り値となる
*//**************************************************************************/
MofBool CGameApp::Initialize(void){
	//リソース配置ディレクトリの設定
	CUtilities::SetCurrentDirectory("Resource");

	gCameraPosition = Vector3(0, 6.0f, -17.0f); // カメラポジション
	gTargetPosition = Vector3(0, 0, -10);		// ターゲットのポジション
	gUpVector		= Vector3(0, 1, 0);			// アップベクトル

	gCamera.SetViewPort();

	gCamera.LookAt(
		gCameraPosition,	// カメラポジション
		gTargetPosition,	// ターゲットのポジション
		gUpVector);			// アップベクトル

	gCamera.PerspectiveFov(MOF_ToRadian(60), 1024.0f / 768.0f, 0.01f, 1000.0f);
	CGraphicsUtilities::SetCamera(&gCamera);
	gRotUp = 0;

	gLight.SetDirection(Vector3(-1, -2, 1.5f));
	gLight.SetDiffuse(MOF_COLOR_HGREEN);
	gLight.SetAmbient(MOF_COLOR_HBLUE);
	gLight.SetSpeculer(MOF_COLOR_WHITE);
	CGraphicsUtilities::SetDirectionalLight(&gLight);

	gPlayer.Load();
	gStage.Load();

	// 敵弾の素材読み込み
	gEnemyShotMesh.Load("eshot.mom");

	gPlayer.Initialize();
	// ステージの状態初期化
	gStage.Initialize(&gStg1EnemyStart);
	// 敵の初期化
	for (int i = 0; i < ENEMY_MAX_COUNT; i++)
	{
		gEnemyArray[i].Initialize();
	}

	// 敵弾の初期化
	for (int i = 0; i < ENEMYSHOT_COUNT; i++)
	{
		gShotArray[i].Initialize();
		gShotArray[i].SetMesh(&gEnemyShotMesh);
	}

	return TRUE;
}
/*************************************************************************//*!
		@brief			アプリケーションの更新
		@param			None
				
		@return			TRUE		成功<br>
						それ以外	失敗、エラーコードが戻り値となる
*//**************************************************************************/

MofBool CGameApp::Update(void){
	//キーの更新
	g_pInput->RefreshKey();
	
	gStage.Update(gEnemyArray, ENEMY_MAX_COUNT);

	gPlayer.Update();

	// 敵の更新
	for (int i = 0; i < ENEMY_MAX_COUNT; i++)
	{
		gEnemyArray[i].SetTargetPos(gPlayer.GetPosition());
		gEnemyArray[i].Update(gShotArray, ENEMYSHOT_COUNT);
	}
	// 敵弾の更新
	for (int i = 0; i < ENEMYSHOT_COUNT; i++)
	{
		gShotArray[i].Update(gPlayer.GetPosition());
	}

	// 敵との当たり判定
	for (int i = 0; i < ENEMY_MAX_COUNT; i++)
	{
		gPlayer.CollisionEnemy(gEnemyArray[i]);
	}
	// 敵弾との当たり判定
	for (int i = 0; i < ENEMYSHOT_COUNT; i++)
	{
		gPlayer.CollisionEnemyShot(gShotArray[i]);
	}

	if (g_pInput->IsKeyPush(MOFKEY_F1)) {
		gbDebug = ((gbDebug) ? false : true);
	}
	// ゲームオーバー表示後に Enter で初期化を行う
	if (g_pInput->IsKeyPush(MOFKEY_RETURN) && gPlayer.IsDead())
	{
		// ゲーム内のオブジェクトをすべて初期化する
		gPlayer.Initialize();
		gStage.Initialize(&gStg1EnemyStart);
		for (int i = 0; i < ENEMY_MAX_COUNT; i++)
		{
			gEnemyArray[i].Initialize();
		}
		for (int i = 0; i < ENEMYSHOT_COUNT; i++)
		{
			gShotArray[i].Initialize();
		}

	}

	float posx = gPlayer.GetPosition().x * 0.4f;
	
	gCameraPosition.x = gTargetPosition.x = posx;
	gCamera.LookAt(gCameraPosition, gTargetPosition, gUpVector);
	
	gUpVector = Vector3(0, 1, 0);
	
	if (gPlayer.GetMove() != PlayerMove::IDLE){
		float v = 0;
		v = (gPlayer.GetMove() == PlayerMove::RIGHT) ? 0.1f : -0.1f;
		gRotUp = MOF_LERP(gRotUp, v, 0.01f);
		gUpVector.RotationZ(gRotUp);
	}
	else {
		gRotUp = MOF_LERP(gRotUp, 0, 0.1f);
		gUpVector.RotationZ(gRotUp);
	}

	gCamera.Update();
	return TRUE;
}

/*************************************************************************//*!
		@brief			アプリケーションの描画
		@param			None
				
		@return			TRUE		成功<br>
						それ以外	失敗、エラーコードが戻り値となる
*//**************************************************************************/
MofBool CGameApp::Render(void){
	//描画処理
	g_pGraphics->RenderStart();
	// 画面のクリア
	g_pGraphics->ClearTarget(0.65f,0.65f,0.67f,0.0f,1.0f,0);

	g_pGraphics->SetDepthEnable(true);

	gStage.Render();

	gPlayer.Render();
	
	// 敵の描画
	for (int i = 0; i < ENEMY_MAX_COUNT; i++)
	{
		gEnemyArray[i].Render();
	}
	// 敵弾の描画
	for (int i = 0; i < ENEMYSHOT_COUNT; i++)
	{
		gShotArray[i].Render();
	}

	if (gbDebug) {
		// プレイヤーのデバッグ描画
		gPlayer.RenderDebug();
		// 敵のデバッグ描画
		for (int i = 0; i < ENEMY_MAX_COUNT; i++)
		{
			gEnemyArray[i].RenderDebug();
		}
		// 敵弾のデバッグ描画
		for (int i = 0; i < ENEMYSHOT_COUNT; i++)
		{
			gShotArray[i].RenderDebug();
		}

		CMatrix44 matworld;
		matworld.Scaling(FIELD_HALF_X * 2, 1, FIELD_HALF_Z * 2);
		CGraphicsUtilities::RenderPlane(matworld, Vector4(1, 1, 1, 0.4f));		
	}
	g_pGraphics->SetDepthEnable(false);

	if (gbDebug) {
		gPlayer.RenderDebugText();
		gStage.RenderDebugText();
		// 敵のデバッグ文字描画
		for (int i = 0; i < ENEMY_MAX_COUNT; i++)
		{
			gEnemyArray[i].RenderDebugText(i);
		}
	}

	// ゲームオーバー表示
	if (gPlayer.IsDead())
	{
		CGraphicsUtilities::RenderString(240, 350, MOF_COLOR_RED,
			"ゲームオーバー ： Enter キーでもう一度最初から");
	}

	// 描画の終了
	g_pGraphics->RenderEnd();
	return TRUE;
}
/*************************************************************************//*!
		@brief			アプリケーションの解放
		@param			None
				
		@return			TRUE		成功<br>
						それ以外	失敗、エラーコードが戻り値となる
*//**************************************************************************/
MofBool CGameApp::Release(void){
	gPlayer.Release();
	gStage.Release();
	gEnemyShotMesh.Release();

	return TRUE;
}